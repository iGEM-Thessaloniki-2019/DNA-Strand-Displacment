#!/usr/bin/env python
#
# crnsimulator.odelib_template: A template for a compiled ODE solver.
# ... or an autogenerated script from the *crnsimulator* Python package
#
# Written by Stefan Badelt (badelt@caltech.edu).
#
# Use at your own risk.
#
#

#
# If this file is executable, it contains a system of hardcoded ODEs together
# with some default parameters. It is recommended to edit the source directly
# at "crnsimulator.odelib_template" or provide your own template file.
#
# call with: python odesystem.py --help
#

from __future__ import print_function
import argparse
import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import odeint

# Uncomment this section for seaborn plot-style
#import seaborn as sns
# sns.set()
#sns.set_context("notebook", font_scale=1, rc={"lines.linewidth": 2.0})


def ode_plotter(name, t, ny, svars, log=False, labels=None):
    """ Plots the ODE trajectories.

    Args:
      name (str): Name of the outputfile including extension (e.g. *.pdf)
      t (list[flt]) : time units plotted on the x-axis.
      ny (list[list[flt]]) : a list of trajectories plotted on the y-axis.
      svars (list[str]): A list of names for every trajectory in ny
      log (bool,optional): Plot data on a logarithmic time scale
      labels (set(),optional): Define species that appear labelled in the plot

    Prints:
      A file containing the plot (Format *.pdf, *.png, etc.)

    Returns:
      [str]: Name of the file containing the plot
    """
    fig, ax = plt.subplots(1, 1, figsize=(7, 3.25))

    # b : blue.
    # g : green.
    # r : red.
    # c : cyan.
    # m : magenta.
    # y : yellow.
    # k : black.
    mycolors = list('bgrcmyk')

    if labels:
        i = 0
        for e, y in enumerate(ny):
            if svars[e] in labels:
                ax.plot(t, y, '-', label=svars[e], color=mycolors[i])
                i = i + 1 if i < len(mycolors) - 1 else 0
            else:
                ax.plot(t, y, '--', color='gray')
    else:
        for e, y in enumerate(ny):
            ax.plot(t, y, '-', label=svars[e])

    # Common custom adjustments:
    # ax.plot(t, y, '-', zorder=2, lw=1.5, color='green', label=svars[e])
    # plt.title('A title for my plot')

    ax.set_xlabel('Time [s]', fontsize=16)
    ax.set_ylabel('Concentration [M]', fontsize=16)
    if log:
        ax.set_xscale('log')
    else:
        ax.set_xscale('linear')

    plt.legend()
    fig.tight_layout()
    # plt.show()
    plt.savefig(name)
    return name


rates = {
    
}

def odesystem(p0, t0, r):
    B1, B1_B1_to_B1_B1, B1_BA_to_B1_BA, B1_I1_to_B1_I1, B1_IA_to_B1_IA, BA, BA_BA_to_BA_BA, BA_I1_to_B1_IA, BA_I1_to_BA_I1, BA_IA_to_BA_IA, I1, I1_I1_to_I1_I1, I1_IA_to_I1_IA, IA, IA_IA_to_IA_IA = p0
    if not r : r = rates


    dB1dt = -301618000.0*B1**2 - 103040000.0*B1*BA - 116759000.0*B1*I1 - 3686320.0*B1*IA + 4586100.0*B1_B1_to_B1_B1 + 164524.0*B1_BA_to_B1_BA + 4413390.0*B1_I1_to_B1_I1 + 1818740.0*B1_IA_to_B1_IA + 281.329*BA_I1_to_B1_IA
    dB1_B1_to_B1_B1dt = 150809000.0*B1**2 - 2293050.0*B1_B1_to_B1_B1
    dB1_BA_to_B1_BAdt = 103040000.0*B1*BA - 164524.0*B1_BA_to_B1_BA
    dB1_I1_to_B1_I1dt = 116759000.0*B1*I1 - 4413390.0*B1_I1_to_B1_I1
    dB1_IA_to_B1_IAdt = 3686320.0*B1*IA - 1818740.0*B1_IA_to_B1_IA
    dBAdt = -103040000.0*B1*BA + 164524.0*B1_BA_to_B1_BA - 117769000.0*BA**2 - 93251870.0*BA*I1 - 2143750.0*BA*IA + 330440.0*BA_BA_to_BA_BA + 36444.2*BA_I1_to_BA_I1 + 1797320.0*BA_IA_to_BA_IA
    dBA_BA_to_BA_BAdt = 58884500.0*BA**2 - 165220.0*BA_BA_to_BA_BA
    dBA_I1_to_B1_IAdt = 1667770.0*BA*I1 - 281.329*BA_I1_to_B1_IA
    dBA_I1_to_BA_I1dt = 91584100.0*BA*I1 - 36444.2*BA_I1_to_BA_I1
    dBA_IA_to_BA_IAdt = 2143750.0*BA*IA - 1797320.0*BA_IA_to_BA_IA
    dI1dt = -116759000.0*B1*I1 + 4413390.0*B1_I1_to_B1_I1 - 93251870.0*BA*I1 + 36444.2*BA_I1_to_BA_I1 - 202304000.0*I1**2 - 3570200.0*I1*IA + 6005340.0*I1_I1_to_I1_I1 + 1263750.0*I1_IA_to_I1_IA
    dI1_I1_to_I1_I1dt = 101152000.0*I1**2 - 3002670.0*I1_I1_to_I1_I1
    dI1_IA_to_I1_IAdt = 3570200.0*I1*IA - 1263750.0*I1_IA_to_I1_IA
    dIAdt = -3686320.0*B1*IA + 1818740.0*B1_IA_to_B1_IA - 2143750.0*BA*IA + 281.329*BA_I1_to_B1_IA + 1797320.0*BA_IA_to_BA_IA - 3570200.0*I1*IA + 1263750.0*I1_IA_to_I1_IA - 295380.0*IA**2 + 44739400.0*IA_IA_to_IA_IA
    dIA_IA_to_IA_IAdt = 147690.0*IA**2 - 22369700.0*IA_IA_to_IA_IA
    return np.array([dB1dt, dB1_B1_to_B1_B1dt, dB1_BA_to_B1_BAdt, dB1_I1_to_B1_I1dt, dB1_IA_to_B1_IAdt, dBAdt, dBA_BA_to_BA_BAdt, dBA_I1_to_B1_IAdt, dBA_I1_to_BA_I1dt, dBA_IA_to_BA_IAdt, dI1dt, dI1_I1_to_I1_I1dt, dI1_IA_to_I1_IAdt, dIAdt, dIA_IA_to_IA_IAdt])

def jacobian(p0, t0, r):
    B1, B1_B1_to_B1_B1, B1_BA_to_B1_BA, B1_I1_to_B1_I1, B1_IA_to_B1_IA, BA, BA_BA_to_BA_BA, BA_I1_to_B1_IA, BA_I1_to_BA_I1, BA_IA_to_BA_IA, I1, I1_I1_to_I1_I1, I1_IA_to_I1_IA, IA, IA_IA_to_IA_IA = p0
    if not r : r = rates


    J = [[[] for i in range(len(p0))] for j in range(len(p0))]
    J[0][0] = -603236000.0*B1 - 103040000.0*BA - 116759000.0*I1 - 3686320.0*IA
    J[0][1] = 4586100.00000000
    J[0][2] = 164524.000000000
    J[0][3] = 4413390.00000000
    J[0][4] = 1818740.00000000
    J[0][5] = -103040000.0*B1
    J[0][6] = 0
    J[0][7] = 281.329000000000
    J[0][8] = 0
    J[0][9] = 0
    J[0][10] = -116759000.0*B1
    J[0][11] = 0
    J[0][12] = 0
    J[0][13] = -3686320.0*B1
    J[0][14] = 0
    J[1][0] = 301618000.0*B1
    J[1][1] = -2293050.00000000
    J[1][2] = 0
    J[1][3] = 0
    J[1][4] = 0
    J[1][5] = 0
    J[1][6] = 0
    J[1][7] = 0
    J[1][8] = 0
    J[1][9] = 0
    J[1][10] = 0
    J[1][11] = 0
    J[1][12] = 0
    J[1][13] = 0
    J[1][14] = 0
    J[2][0] = 103040000.0*BA
    J[2][1] = 0
    J[2][2] = -164524.000000000
    J[2][3] = 0
    J[2][4] = 0
    J[2][5] = 103040000.0*B1
    J[2][6] = 0
    J[2][7] = 0
    J[2][8] = 0
    J[2][9] = 0
    J[2][10] = 0
    J[2][11] = 0
    J[2][12] = 0
    J[2][13] = 0
    J[2][14] = 0
    J[3][0] = 116759000.0*I1
    J[3][1] = 0
    J[3][2] = 0
    J[3][3] = -4413390.00000000
    J[3][4] = 0
    J[3][5] = 0
    J[3][6] = 0
    J[3][7] = 0
    J[3][8] = 0
    J[3][9] = 0
    J[3][10] = 116759000.0*B1
    J[3][11] = 0
    J[3][12] = 0
    J[3][13] = 0
    J[3][14] = 0
    J[4][0] = 3686320.0*IA
    J[4][1] = 0
    J[4][2] = 0
    J[4][3] = 0
    J[4][4] = -1818740.00000000
    J[4][5] = 0
    J[4][6] = 0
    J[4][7] = 0
    J[4][8] = 0
    J[4][9] = 0
    J[4][10] = 0
    J[4][11] = 0
    J[4][12] = 0
    J[4][13] = 3686320.0*B1
    J[4][14] = 0
    J[5][0] = -103040000.0*BA
    J[5][1] = 0
    J[5][2] = 164524.000000000
    J[5][3] = 0
    J[5][4] = 0
    J[5][5] = -103040000.0*B1 - 235538000.0*BA - 93251870.0*I1 - 2143750.0*IA
    J[5][6] = 330440.000000000
    J[5][7] = 0
    J[5][8] = 36444.2000000000
    J[5][9] = 1797320.00000000
    J[5][10] = -93251870.0*BA
    J[5][11] = 0
    J[5][12] = 0
    J[5][13] = -2143750.0*BA
    J[5][14] = 0
    J[6][0] = 0
    J[6][1] = 0
    J[6][2] = 0
    J[6][3] = 0
    J[6][4] = 0
    J[6][5] = 117769000.0*BA
    J[6][6] = -165220.000000000
    J[6][7] = 0
    J[6][8] = 0
    J[6][9] = 0
    J[6][10] = 0
    J[6][11] = 0
    J[6][12] = 0
    J[6][13] = 0
    J[6][14] = 0
    J[7][0] = 0
    J[7][1] = 0
    J[7][2] = 0
    J[7][3] = 0
    J[7][4] = 0
    J[7][5] = 1667770.0*I1
    J[7][6] = 0
    J[7][7] = -281.329000000000
    J[7][8] = 0
    J[7][9] = 0
    J[7][10] = 1667770.0*BA
    J[7][11] = 0
    J[7][12] = 0
    J[7][13] = 0
    J[7][14] = 0
    J[8][0] = 0
    J[8][1] = 0
    J[8][2] = 0
    J[8][3] = 0
    J[8][4] = 0
    J[8][5] = 91584100.0*I1
    J[8][6] = 0
    J[8][7] = 0
    J[8][8] = -36444.2000000000
    J[8][9] = 0
    J[8][10] = 91584100.0*BA
    J[8][11] = 0
    J[8][12] = 0
    J[8][13] = 0
    J[8][14] = 0
    J[9][0] = 0
    J[9][1] = 0
    J[9][2] = 0
    J[9][3] = 0
    J[9][4] = 0
    J[9][5] = 2143750.0*IA
    J[9][6] = 0
    J[9][7] = 0
    J[9][8] = 0
    J[9][9] = -1797320.00000000
    J[9][10] = 0
    J[9][11] = 0
    J[9][12] = 0
    J[9][13] = 2143750.0*BA
    J[9][14] = 0
    J[10][0] = -116759000.0*I1
    J[10][1] = 0
    J[10][2] = 0
    J[10][3] = 4413390.00000000
    J[10][4] = 0
    J[10][5] = -93251870.0*I1
    J[10][6] = 0
    J[10][7] = 0
    J[10][8] = 36444.2000000000
    J[10][9] = 0
    J[10][10] = -116759000.0*B1 - 93251870.0*BA - 404608000.0*I1 - 3570200.0*IA
    J[10][11] = 6005340.00000000
    J[10][12] = 1263750.00000000
    J[10][13] = -3570200.0*I1
    J[10][14] = 0
    J[11][0] = 0
    J[11][1] = 0
    J[11][2] = 0
    J[11][3] = 0
    J[11][4] = 0
    J[11][5] = 0
    J[11][6] = 0
    J[11][7] = 0
    J[11][8] = 0
    J[11][9] = 0
    J[11][10] = 202304000.0*I1
    J[11][11] = -3002670.00000000
    J[11][12] = 0
    J[11][13] = 0
    J[11][14] = 0
    J[12][0] = 0
    J[12][1] = 0
    J[12][2] = 0
    J[12][3] = 0
    J[12][4] = 0
    J[12][5] = 0
    J[12][6] = 0
    J[12][7] = 0
    J[12][8] = 0
    J[12][9] = 0
    J[12][10] = 3570200.0*IA
    J[12][11] = 0
    J[12][12] = -1263750.00000000
    J[12][13] = 3570200.0*I1
    J[12][14] = 0
    J[13][0] = -3686320.0*IA
    J[13][1] = 0
    J[13][2] = 0
    J[13][3] = 0
    J[13][4] = 1818740.00000000
    J[13][5] = -2143750.0*IA
    J[13][6] = 0
    J[13][7] = 281.329000000000
    J[13][8] = 0
    J[13][9] = 1797320.00000000
    J[13][10] = -3570200.0*IA
    J[13][11] = 0
    J[13][12] = 1263750.00000000
    J[13][13] = -3686320.0*B1 - 2143750.0*BA - 3570200.0*I1 - 590760.0*IA
    J[13][14] = 44739400.0000000
    J[14][0] = 0
    J[14][1] = 0
    J[14][2] = 0
    J[14][3] = 0
    J[14][4] = 0
    J[14][5] = 0
    J[14][6] = 0
    J[14][7] = 0
    J[14][8] = 0
    J[14][9] = 0
    J[14][10] = 0
    J[14][11] = 0
    J[14][12] = 0
    J[14][13] = 295380.0*IA
    J[14][14] = -22369700.0000000
    return J


def add_integrator_args(parser):
    """ODE integration aruments."""

    parser.add_argument("--list", action='store_true',
            help="Print all species and exit.")

    # required: simulation time and output settings
    parser.add_argument("--t0", type=float, default=0, metavar='<flt>',
            help="First time point of the time-course.")
    parser.add_argument("--t8", type=float, default=100000, metavar='<flt>',
            help="End point of simulation time.")
    parser.add_argument("--t-lin", type=int, default=50000, metavar='<int>',
            help="Returns --t-lin evenly spaced numbers on a linear scale from --t0 to --t8.")
    parser.add_argument("--t-log", type=int, default=None, metavar='<int>',
            help="Returns --t-log evenly spaced numbers on a logarithmic scale from --t0 to --t8.")

    # required: initial concentration vector
    parser.add_argument("--p0", nargs='+', metavar='<int/str>=<flt>',
            help="""Vector of initial species concentrations. 
            E.g. \"--p0 1=0.5 3=0.7\" stands for 1st species at a concentration of 0.5 
            and 3rd species at a concentration of 0.7. You may chose to address species
            directly by name, e.g.: --p0 C=0.5.""")

    # optional: choose output formats
    parser.add_argument("--nxy", action='store_true',
            help="Print time course in nxy format.")
    parser.add_argument("--pyplot", default='', metavar='<str>',
            help="Specify a filename to plot the ODE simulation.")
    parser.add_argument("--pyplot-labels", nargs='+', default=[], metavar='<str>+',
            help="Specify the species which should appear in the pyplot legend.")

    # advanced: scipy.integrate.odeint parameters
    parser.add_argument("-a", "--atol", type=float, default=None, metavar='<flt>',
            help="Specify absolute tolerance for the solver.")
    parser.add_argument("-r", "--rtol", type=float, default=None, metavar='<flt>',
            help="Specify relative tolerance for the solver.")
    parser.add_argument("--mxstep", type=int, default=0, metavar='<int>',
            help="Maximum number of steps allowed for each integration point in t.")

    return


def integrate(args):
    """Main interface to solve the ODE-system.

    Args:
      args (:obj:`argparse.ArgumentParser()`): An argparse object containing all of
        the arguments of :obj:`crnsimulator.add_integrator_args()`.

    Prints:
      - verbose information
      - plot files
      - time-course

    Returns:
      Nothing
    """

    svars = ["B1", "B1_B1_to_B1_B1", "B1_BA_to_B1_BA", "B1_I1_to_B1_I1", "B1_IA_to_B1_IA", "BA", "BA_BA_to_BA_BA", "BA_I1_to_B1_IA", "BA_I1_to_BA_I1", "BA_IA_to_BA_IA", "I1", "I1_I1_to_I1_I1", "I1_IA_to_I1_IA", "IA", "IA_IA_to_IA_IA"]

    p0 = [0] * len(svars)
    

    if args.list:
        for e, v in enumerate(svars, 1):
            print('#', e, v)
        raise SystemExit('# Specify a vector of initial concentrations: ' +
                'e.g. --p0 1=0.1 2=0.005 3=1e-6 (see --help)')

    if not args.nxy and not args.pyplot:
        print('# Use --pyplot and/or --nxy to plot your results.')

    if not args.t8:
        raise ValueError(
            'Specify a valid end-time for the simulation: --t8 <flt>')

    if args.t_log:
        if args.t0 == 0:
            raise ValueError('--t0 cannot be 0 when using log-scale!')
        time = np.logspace(
            np.log10(
                args.t0), np.log10(
                args.t8), num=args.t_log)
    elif args.t_lin:
        time = np.linspace(args.t0, args.t8, num=args.t_lin)
    else:
        raise ValueError('Please specify either --t-lin or --t-log. (see --help)')

    if not args.p0:
        print('# Initial concentrations:', list(zip(svars, p0)))
        if sum(p0) == 0:
            for e, v in enumerate(svars, 1):
                print('#', e, v)
            raise SystemExit('# -- Must specify a vector of initial concentrations: ' +
                             'e.g. --p0 1=0.1 2=0.005 3=1e-6 (see --help)')
    else:
        for term in args.p0:
            p, o = term.split('=')
            try:
                pi = svars.index(p)
            except ValueError as e:
                pi = int(p) - 1
            finally:
                p0[pi] = float(o)
        print('# Initial concentrations:', list(zip(svars, p0)))

    # TODO: It would be nice if it is possible to read alternative rates from a file instead.
    # None triggers the default-rates that are hard-coded in the (this)
    # library file.
    rates = None

    ny = odeint(odesystem,
        p0, time, (rates, ), Dfun = jacobian,
        atol=args.atol, rtol=args.rtol, mxstep=args.mxstep).T

    if args.nxy:
        for i in zip(time, *ny):
            print(' '.join(map("{:.9e}".format, i)))

    if args.pyplot:
        plotfile = ode_plotter(args.pyplot, time, ny, svars,
                               log=True if args.t_log else False,
                               labels=set(args.pyplot_labels))
        print('# Printed file:', plotfile)

    return zip(time, *ny)


if __name__ == '__main__':
    parser = argparse.ArgumentParser(
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)

    add_integrator_args(parser)

    args = parser.parse_args()

    integrate(args)
